---
subtitle: Supplementary analysis file
format:
  html:
    toc: true
    toc-depth: 2
    toc-title: Contents
    theme: materia
    mainfont: LibertinusSansRegular
    monofont: FiraCodeRegular
    code-fold: true
    # code-link: true # Slow
    code-tools: true
    header-includes: |
      <link rel="stylesheet" media="screen" href="https://fontlibrary.org//face/fira-code" type="text/css"/>
      <link rel="stylesheet" media="screen" href="https://fontlibrary.org//face/libertinus-sans" type="text/css"/> 
---

```{r document-options}
#| include: false
knitr::opts_chunk$set(
  message = FALSE,
  cache = TRUE,
  warning = FALSE,
  echo = TRUE
)
```

NOTE: This is just a bit of a notebook at the moment.

```{r}
#| label: packages
#| code-summary: R Packages
#| cache: false

library(patchwork)
library(gt)
library(modelr)
library(scales)
library(broom)
library(ggdist)
library(distributional)
library(tidyverse)

theme_set(
  theme_linedraw() +
    theme(
      strip.background = element_rect(fill = NA, color = NA), 
      strip.text = element_text(colour = "black", hjust = 0), 
      panel.grid = element_blank()
    )
)
```

# Modelling strategy

Here's our thinking of the modelling strategy at this point. Although this is not a pre-post experiment, it helps to label the setup as such:

- We rescale the original mood values from 0-1000 to 0-1 for easier interpretation
- We model mood reports for row *i*, person *j*, and session *k* with a normal distribution censored at 0 & 1
- We model the mean $\eta_{ijk}$ on an intercept (mood at pre-measure) and slope (mood difference btwn post and pre) with population level effects, and session and person deviations that are multivariate normal distributed
- We also model the residual deviation: random intercepts by person and probably by session too.

Here is a sketch of this analysis for one person

```{r}
#| label: fig-example
#| fig-cap: Sketch of the modelling strategy for one participant
#| fig-height: 3
library(lme4)
library(latex2exp)

dat <- dat |> 
  mutate(
    i = row_number(),
    i = factor(i == 1, levels = c(TRUE, FALSE), labels = c("pre", "post")),
    .by = c(pid, session)
  )

tmp <- dat |> 
  filter(pid == "p10004") |> 
  mutate(session = str_glue("{pid} (session: {session})"))
x <- lmer(
  mood ~ 0 + i + (0 + i | session), data = tmp 
)

# Ugly code >>> no code
newx <- tmp |> 
  data_grid(duration = seq_range(duration, 10), i, session)
newx$.fitted <- predict(x, newdata = newx)

newy <- tmp |> 
  data_grid(duration = seq_range(duration, 10), i)
newy$.fitted <- predict(x, newdata = newy, re.form = NA)
newy <- newy |> 
  mutate(session = "p10004 (all data)")
tmp2 <- tmp |> 
  mutate(session = "p10004 (all data)")

tmp <- bind_rows(tmp, tmp2)
newx <- bind_rows(newx, newy)

labels <- coef(x)$session |> 
  as.data.frame() |> 
  rownames_to_column("session") |> 
  mutate(duration = 50)

labels2 <- fixef(x) |> t() |> 
  data.frame() |> 
  mutate(session = "p10004 (all data)", duration = 50)

labels <- bind_rows(labels, labels2)

tmp |> 
  mutate(session = fct_inorder(session)) |> 
  ggplot() +
  aes(duration, mood, col = i) +
  scale_color_brewer(
    "Pre-session measure",
    palette = "Set1",
    aesthetics = c("color", "fill")
  ) +
  scale_x_continuous(
    "Session duration (mins)"
  ) +
  scale_y_continuous(
    "Mood",
    limits = c(0, 1)
  ) +
  geom_line(
    data = newx |> mutate(session = fct_inorder(session)),
    aes(y = .fitted)
  ) +
  geom_segment(
    data = labels |> mutate(session = fct_inorder(session)),
    aes(x = duration, xend = duration, y = ipre, yend = ipost, col = "diff"),
    arrow = arrow(length = unit(5, "pt"), ends = "both", type = "closed")
  ) +
  geom_point() +
  labs(caption = "mood ~ 1 + post + (1 + post | session)") +
  facet_wrap("session", nrow = 1) +
  theme(legend.position = "bottom")
```

# Session info

```{r}
cat(
  "This output from",
  "\nFile:", knitr::current_input(),
  "\nCommit: ", gert::git_commit_id(),
  "\nRepo:", gert::git_remote_info()$url
)
sessionInfo()
```

