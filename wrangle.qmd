# Wrangle {#sec-wrangle}

This notebook wrangles the raw data on OSF to something more suitable for our current analyses.

```{r}
#| label: setup
#| include: false

knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  cache = TRUE,
  include = TRUE,
  echo = TRUE
)
```

Load some packages:

```{r}
#| label: packages
#| cache: false

library(patchwork)
library(tidyverse)
source("R/functions.R")
```

## Raw data

Download data from OSF:

```{r}
#| label: data-download

# Download, unzip data from OSF PWS database
path <- "data-raw/data.zip"
if (!file.exists(path)) {
  dir.create("data-raw", FALSE)
  download.file(
    url = "https://osf.io/download/j48qf/",
    destfile = "data-raw/data.zip"
  )
  dir.create("data", FALSE)
  unzip(
    zipfile = path,
    files = c("data/demographics.csv", "data/study_prompt_answered.csv")
  )
}
```

Load data and rename and rescale variables:

```{r}
#| label: data-load

dat <- read_csv(
  "data/study_prompt_answered.csv",
  col_select = c(
    pid,
    time = Time_utc,
    duration = CurrentSessionLength,
    prompt = LastStudyPromptType,
    mood = response
  )
)
dat <- dat |> 
  mutate(
    pid = factor(pid),
    # Mood to 0-100 scale
    mood = mood / 10, 
    # hours indicates session duration in hours
    hours = duration / 60,
    .keep = "unused"
  )
```

## Sessions

Mood responses were recorded with a session length indicator, which was reset to 0 when players started the game. We therefore create a session indicator that increments from 1 whenever the observation's session duration is less than the previous one.

```{r}
#| label: session-indicator-create
dat <- dat |> 
  # filter(hours <= 5) |> 
  arrange(pid, time) |> 
  mutate(
    new_session = hours < lag(hours, default = 999),
    session = cumsum(new_session),
    .by = pid
  ) |> 
  select(-c(new_session)) |> 
  mutate(ps = paste(pid, session, sep = "_"))

str_glue(
  "Raw data\n",
  "Players: {number2(length(unique(dat$pid)))}\n",
  "Sessions: {number2(length(unique(dat$ps)))}\n",
  "Observations: {number2(nrow(dat))}\n"
)
```

Roughly 10% of sessions should have a mood prompt at login. However, many sessions are short and only have the login prompt when just the response data is considered. Therefore, in the current data the proportion will be somewhat greater than 10%.

```{r}
# What proportion of sessions have a login mood prompt?
dat |> 
  mutate(
    has_login_prompt = any(hours == 0 & prompt == "Wellbeing"),
    .by = ps
  ) |> 
  distinct(ps, has_login_prompt) |> 
  summarise(mean(has_login_prompt))
```

## Response types

We then filter out all but the mood (Wellbeing) item responses

```{r}
#| label: mood-filter

# Include only wellbeing responses that occurred
# in sessions with both "pre" and "post" measures
dat <- dat |>
  filter(prompt == "Wellbeing") |>
  select(-prompt)

str_glue(
  "Mood-only data\n",
  "Players: {number2(length(unique(dat$pid)))}\n",
  "Sessions: {number2(length(unique(dat$ps)))}\n",
  "Observations: {number2(nrow(dat))}\n"
)
```

## EDA / outliers / exclusions

At this point the data table contains all in-game mood responses of all sessions. It might be reasonable to do some filtering of e.g. long sessions.

```{r}
#| label: fig-session-durations
#| fig-height: 3
#| fig-cap: Summaries of session durations. All x-axes are truncated at 10 hours.

p_durations <- dat |> 
  filter(hours == max(hours), .by = ps) |> 
  ggplot(aes(hours)) +
  scale_x_continuous(
    "Session duration",
    expand = expansion(c(0.05, 0.05))
  ) +
  scale_y_continuous(
    "Sessions",
    expand = expansion(c(0, 0.05))
  ) +
  coord_cartesian(xlim = c(0, 10)) +
  geom_histogram(binwidth = 0.33)

p_mean_durations <- dat |> 
  filter(hours == max(hours), .by = ps) |> 
  summarise(hours = mean(hours), n = n(), .by = pid) |> 
  ggplot(aes(hours)) +
  scale_x_continuous(
    "Mean session duration",
    expand = expansion(c(0.05, 0.05))
  ) +
  scale_y_continuous(
    "Players",
    expand = expansion(c(0, 0.05))
  ) +
  coord_cartesian(xlim = c(0, 10)) +
  geom_histogram(binwidth = 0.33)

p_ecdf_durations <- dat |> 
  filter(hours == max(hours), .by = c(session, pid)) |> 
  ggplot(aes(hours)) +
  scale_x_continuous(
    "Session duration",
    expand = expansion(c(0.05, 0.05))
  ) +
  scale_y_continuous(
    "Cumulative proportion",
    expand = expansion(0.01),
    breaks = (0:10)/10
  ) +
  stat_ecdf() +
  coord_cartesian(xlim = c(0, 10))

p_durations | p_mean_durations | p_ecdf_durations

dat <- dat |> 
  filter(hours <= 5)

str_glue(
  "Mood-only 5<h session data\n",
  "Players: {number2(length(unique(dat$pid)))}\n",
  "Sessions: {number2(length(unique(dat$ps)))}\n",
  "Observations: {number2(nrow(dat))}\n"
)
```

As with many things concerning numbers, we are happy with 5. Finally we just drop observations where participants skipped the prompt

```{r}
#| label: drop-missing-data

dat <- dat |> 
  drop_na()

str_glue(
  "Mood-only 5<h session non-missing data\n",
  "Players: {number2(length(unique(dat$pid)))}\n",
  "Sessions: {number2(length(unique(dat$ps)))}\n",
  "Observations: {number2(nrow(dat))}\n"
)
```

## Save data

```{r}
dir.create("data", FALSE)
saveRDS(dat, "data/data.rds")
```

